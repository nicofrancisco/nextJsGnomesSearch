{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/Users/nicolasfbergues/Desktop/Nico/Trabajo/Aerolab/NextDemo/learnnextjs-demo/pages/components/AutoCompleteInput/AutoCompleteInput.jsx\";\nvar __jsx = React.createElement;\n// @flow\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Suggestions from \"./Suggestions/Suggestions\";\nimport { ContainerInput, InputSearch } from \"./AutoCompleteInputStyled\";\n\nvar AutoCompleteInput = /*#__PURE__*/function (_Component) {\n  _inherits(AutoCompleteInput, _Component);\n\n  function AutoCompleteInput() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, AutoCompleteInput);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AutoCompleteInput)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      searchTerm: \"\",\n      open: false,\n      suggestedItems: [],\n      currentOption: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"parseNamesFormat\", function () {\n      var items = _this.props.autoCompleteItems.slice();\n\n      var valuesToRemove = ['\"', ','];\n      var filteredItems = items.filter(function (item) {\n        return !valuesToRemove.includes(item);\n      });\n      console.log(filteredItems); // [\"a\", \"b\", \"e\", \"f\"]\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClickOutside\", function (event) {\n      // Control when user clicks outside the input components\n      // if the suggestions box is open when click uutside will close the\n      // box\n\n      /* eslint-disable */\n      // IT'S BEST PRACTICE TO USE REF INSTEAD\n      // I had to use finDOMNode method provisionally since\n      // i'm having problems implementing ref\n      var thisComponent = ReactDOM.findDOMNode(_assertThisInitialized(_this));\n      /* eslint-enable */\n\n      if (!thisComponent || !thisComponent.contains(event.target)) {\n        _this.setState({\n          open: false\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateLocalState\", function (state) {\n      return _this.setState(state);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateParentState\", function (searchTerm) {\n      _this.props.parentUpdateState(searchTerm);\n    });\n\n    return _this;\n  }\n\n  _createClass(AutoCompleteInput, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // When component mount listen click event when click on document\n      document.addEventListener(\"click\", this.handleClickOutside);\n      this.parseNamesFormat();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      // Remove click event handler on document when component unmounts\n      document.removeEventListener(\"click\", this.handleClickOutside);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state = this.state,\n          searchTerm = _this$state.searchTerm,\n          open = _this$state.open;\n      return __jsx(ContainerInput, {\n        className: \"autocomplete\",\n        showLabel: this.props.showLabel,\n        htmlFor: this.props.stateName,\n        maxWidth: this.props.maxWidth,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 77\n        },\n        __self: this\n      }, this.props.labelName.length > 0 && __jsx(\"span\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 84\n        },\n        __self: this\n      }, \" \", this.props.labelName, \" \"), __jsx(InputSearch, {\n        autoComplete: \"off\",\n        type: \"text\",\n        id: this.props.stateName,\n        onChange: AutoCompleteInput.handleTermChange(this.updateLocalState, this.updateParentState, this.props.updateCurrentPage, this.props.autoCompleteItems, this.props.maxSuggests, this.props.includeSearchTerm),\n        onFocus: AutoCompleteInput.handleFocusInput(this.updateLocalState, searchTerm, this.updateParentState),\n        onKeyDown: AutoCompleteInput.handleCloseAutoComplete(this.updateLocalState, this.state, this.updateParentState, this.props.updateCurrentPage),\n        value: searchTerm,\n        placeholder: this.props.placeholder,\n        open: open && searchTerm.length > 0 ? open : false,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 86\n        },\n        __self: this\n      }), __jsx(Suggestions, _extends({\n        open: open,\n        maxWidth: this.props.maxWidth,\n        updateLocalState: this.updateLocalState,\n        updateParentState: this.updateParentState\n      }, this.state, this.props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 113\n        },\n        __self: this\n      })));\n    }\n  }]);\n\n  return AutoCompleteInput;\n}(Component); // this approach on declaring events handlers improves\n// Readability and maintainance also improve time loading\n// since the class and components will be read first by\n// the browser engine - also it's the unique reference for all\n// others components which would need this\n// Handling onChange event\n// it will receive data to update the parent state\n\n\n_defineProperty(AutoCompleteInput, \"defaultProps\", {\n  maxSuggests: 5,\n  maxWidth: \"300px\",\n  includeSearchTerm: false,\n  labelName: \"\",\n  showLabel: false,\n  placeholder: \"\"\n});\n\nAutoCompleteInput.handleTermChange = function (updateLocalState, updateParentState, updateCurrentPage, autoCompleteItems, maxSuggests, includeSearchTerm) {\n  return function (event) {\n    // Differences between e.target and e.currentTarget\n    // target = element that triggered event. or in other words\n    // it could be whatever that's actualy clicked on. It can vary, as this\n    // can be within an element that the event was bound to\n    // currentTarget = element that listens to event.\n    // currentTarget is the element you actually bound the event to.\n    // This will never change.\n    // Since i accessed to the DOM element that's associated with the event handler\n    // I defined, i used currentTarget.\n    // Every time the user type a new letter the filter method\n    // Will detect matches with the names of every gnome in the array\n    var AutoCompleteList = autoCompleteItems.filter(function (autoCompleteItem) {\n      // If the search item is include within the array item this will show\n      // all the options which includes the search items\n      if (includeSearchTerm) {\n        return autoCompleteItem.toLowerCase().indexOf(event.target.value.toLowerCase()) >= 0;\n      } // By default the autocomplete input will show only the options which\n      // search term starts and includes with the search term\n\n\n      return autoCompleteItem.toLowerCase().search(event.target.value.toLowerCase()) === 0;\n    }).splice(0, maxSuggests); // Control how many suggestions will be show\n\n    updateLocalState({\n      searchTerm: event.currentTarget.value,\n      // update the controlled component\n      open: AutoCompleteList.length !== 0,\n      // If there is not a match close the suggestion box\n      suggestedItems: AutoCompleteList,\n      // return an array of all suggestions\n      currentOption: -1 // disable suggest the first item, to enable switch it to 0\n\n    }); // update global state of the parent search term\n\n    updateParentState(event.currentTarget.value); // When search for a new letter pagination will reset to page 1\n\n    updateCurrentPage(0);\n  };\n}; // handle on Focus\n\n\nAutoCompleteInput.handleFocusInput = function (updateLocalState, searchTerm, updateParentState) {\n  return function (event) {\n    event.preventDefault(); // if there are at least one letter in the input and if it is focused\n    // open the box with suggestions\n\n    var open = searchTerm > 0;\n    updateLocalState({\n      open: open\n    });\n    updateParentState(searchTerm);\n  };\n}; // handle on keydown\n\n\nAutoCompleteInput.handleCloseAutoComplete = function (updateLocalState, state, updateParentState, updateCurrentPage) {\n  return function (event) {\n    // When user press ESC key\n    // Close the suggestion box and reset all suggestions\n    if (event.which === 27) {\n      updateLocalState({\n        open: false,\n        suggestedItems: []\n      });\n    } else if (event.keyCode === 13) {\n      // When Enter\n      // if there is a suggested option pass it to the state if not check if -1 and just send the current search term\n      // reset the suggestions and close the box and algo depending of the position\n      // of the current option it will return the suggested option or tbe search Term\n      // only if the current option is bigger or equal to 0 it will return the suggestion\n      var processSearch = state.currentOption === -1 ? state.searchTerm : state.suggestedItems[state.currentOption];\n      updateLocalState({\n        open: false,\n        searchTerm: processSearch,\n        suggestedItems: [],\n        currentOption: -1\n      }); // Get pagination to page 1\n\n      updateCurrentPage(0);\n      updateParentState(processSearch);\n    } else if (event.keyCode === 40) {\n      // When arrow up\n      // select and option controlled by keyboard\n      // everytime the user clicks arrow up button it will decrease\n      // the suggestion options\n      // suggestion options cant be less than -1 so in this case\n      // when click up always returns -1\n      updateLocalState(function (prevState) {\n        var arrayItem = prevState.suggestedItems.length - 1;\n        var maxOption = prevState.currentOption < arrayItem ? prevState.currentOption + 1 : arrayItem;\n        return {\n          currentOption: maxOption\n        };\n      });\n    } else if (event.keyCode === 38) {\n      // When arrow down\n      // select and option controlled by keyboard\n      // everytime the user clicks arrow down button it will increase\n      // the suggestion options\n      updateLocalState(function (prevState) {\n        // If not selected option return -1\n        var minOption = prevState.currentOption < 1 ? -1 : prevState.currentOption - 1;\n        return {\n          currentOption: minOption\n        };\n      });\n    } else if (event.keyCode === 9) {\n      updateLocalState({\n        currentOption: 0,\n        suggestedItems: [],\n        open: false\n      });\n    }\n  };\n};\n\nexport default AutoCompleteInput;","map":{"version":3,"sources":["/Users/nicolasfbergues/Desktop/Nico/Trabajo/Aerolab/NextDemo/learnnextjs-demo/pages/components/AutoCompleteInput/AutoCompleteInput.jsx"],"names":["React","Component","ReactDOM","Suggestions","ContainerInput","InputSearch","AutoCompleteInput","searchTerm","open","suggestedItems","currentOption","items","props","autoCompleteItems","slice","valuesToRemove","filteredItems","filter","item","includes","console","log","event","thisComponent","findDOMNode","contains","target","setState","state","parentUpdateState","document","addEventListener","handleClickOutside","parseNamesFormat","removeEventListener","showLabel","stateName","maxWidth","labelName","length","handleTermChange","updateLocalState","updateParentState","updateCurrentPage","maxSuggests","includeSearchTerm","handleFocusInput","handleCloseAutoComplete","placeholder","AutoCompleteList","autoCompleteItem","toLowerCase","indexOf","value","search","splice","currentTarget","preventDefault","which","keyCode","processSearch","prevState","arrayItem","maxOption","minOption"],"mappings":"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","sourcesContent":["// @flow\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Suggestions from \"./Suggestions/Suggestions\";\nimport { ContainerInput, InputSearch } from \"./AutoCompleteInputStyled\";\n\nclass AutoCompleteInput extends Component{\n  static defaultProps = {\n    maxSuggests: 5,\n    maxWidth: \"300px\",\n    includeSearchTerm: false,\n    labelName: \"\",\n    showLabel: false,\n    placeholder: \"\"\n  };\n\n  state = {\n    searchTerm: \"\",\n    open: false,\n    suggestedItems: [],\n    currentOption: 0\n  };\n\n  componentDidMount() {\n    // When component mount listen click event when click on document\n    document.addEventListener(\"click\", this.handleClickOutside);\n\n    this.parseNamesFormat();\n\n  }\n\n  componentWillUnmount() {\n    // Remove click event handler on document when component unmounts\n    document.removeEventListener(\"click\", this.handleClickOutside);\n  }\n\n  parseNamesFormat = () => {\n    const items = this.props.autoCompleteItems.slice();\n    const valuesToRemove = ['\"', ',']\n    const filteredItems = items.filter(item => !valuesToRemove.includes(item))\n\n    console.log(filteredItems)\n    // [\"a\", \"b\", \"e\", \"f\"]\n\n\n\n  };\n\n\n  handleClickOutside = event => {\n    // Control when user clicks outside the input components\n    // if the suggestions box is open when click uutside will close the\n    // box\n    /* eslint-disable */\n    // IT'S BEST PRACTICE TO USE REF INSTEAD\n    // I had to use finDOMNode method provisionally since\n    // i'm having problems implementing ref\n    const thisComponent = ReactDOM.findDOMNode(this);\n    /* eslint-enable */\n    if (!thisComponent || !thisComponent.contains(event.target)) {\n      this.setState({\n        open: false\n      });\n    }\n  };\n\n  // control the entire state control of this component\n  updateLocalState = (state) => this.setState(state);\n  // This will update parent state which control this component\n  updateParentState = (searchTerm) => {\n    this.props.parentUpdateState(searchTerm);\n  };\n\n  render() {\n    const { searchTerm, open } = this.state;\n    return (\n      <ContainerInput\n        className=\"autocomplete\"\n        showLabel={this.props.showLabel}\n        htmlFor={this.props.stateName}\n        maxWidth={this.props.maxWidth}\n      >\n        {this.props.labelName.length > 0 && (\n          <span> {this.props.labelName} </span>\n        )}\n        <InputSearch\n          autoComplete=\"off\"\n          type=\"text\"\n          id={this.props.stateName}\n          onChange={AutoCompleteInput.handleTermChange(\n            this.updateLocalState,\n            this.updateParentState,\n            this.props.updateCurrentPage,\n            this.props.autoCompleteItems,\n            this.props.maxSuggests,\n            this.props.includeSearchTerm\n          )}\n          onFocus={AutoCompleteInput.handleFocusInput(\n            this.updateLocalState,\n            searchTerm,\n            this.updateParentState\n          )}\n          onKeyDown={AutoCompleteInput.handleCloseAutoComplete(\n            this.updateLocalState,\n            this.state,\n            this.updateParentState,\n            this.props.updateCurrentPage\n          )}\n          value={searchTerm}\n          placeholder={this.props.placeholder}\n          open={open && searchTerm.length > 0 ? open : false}\n        />\n        <Suggestions\n          open={open}\n          maxWidth={this.props.maxWidth}\n          updateLocalState={this.updateLocalState}\n          updateParentState={this.updateParentState}\n          {...this.state}\n          {...this.props}\n        />\n      </ContainerInput>\n    );\n  }\n}\n\n// this approach on declaring events handlers improves\n// Readability and maintainance also improve time loading\n// since the class and components will be read first by\n// the browser engine - also it's the unique reference for all\n// others components which would need this\n\n// Handling onChange event\n// it will receive data to update the parent state\nAutoCompleteInput.handleTermChange = (\n  updateLocalState,\n  updateParentState,\n  updateCurrentPage,\n  autoCompleteItems,\n  maxSuggests,\n  includeSearchTerm,\n) => (event) => {\n  // Differences between e.target and e.currentTarget\n  // target = element that triggered event. or in other words\n  // it could be whatever that's actualy clicked on. It can vary, as this\n  // can be within an element that the event was bound to\n  // currentTarget = element that listens to event.\n  // currentTarget is the element you actually bound the event to.\n  // This will never change.\n\n  // Since i accessed to the DOM element that's associated with the event handler\n  // I defined, i used currentTarget.\n\n  // Every time the user type a new letter the filter method\n  // Will detect matches with the names of every gnome in the array\n  const AutoCompleteList = autoCompleteItems\n    .filter(autoCompleteItem => {\n      // If the search item is include within the array item this will show\n      // all the options which includes the search items\n      if (includeSearchTerm) {\n        return (\n          autoCompleteItem\n            .toLowerCase()\n            .indexOf(event.target.value.toLowerCase()) >= 0\n        );\n      }\n      // By default the autocomplete input will show only the options which\n      // search term starts and includes with the search term\n      return (\n        autoCompleteItem\n          .toLowerCase()\n          .search(event.target.value.toLowerCase()) === 0\n      );\n    })\n    .splice(0, maxSuggests);\n    // Control how many suggestions will be show\n\n  updateLocalState({\n    searchTerm: event.currentTarget.value, // update the controlled component\n    open: AutoCompleteList.length !== 0, // If there is not a match close the suggestion box\n    suggestedItems: AutoCompleteList, // return an array of all suggestions\n    currentOption: -1 // disable suggest the first item, to enable switch it to 0\n  });\n  // update global state of the parent search term\n  updateParentState(event.currentTarget.value);\n  // When search for a new letter pagination will reset to page 1\n  updateCurrentPage(0);\n};\n\n// handle on Focus\nAutoCompleteInput.handleFocusInput = (\n  updateLocalState,\n  searchTerm,\n  updateParentState,\n) => (event) => {\n  event.preventDefault();\n  // if there are at least one letter in the input and if it is focused\n  // open the box with suggestions\n  const open = searchTerm > 0;\n\n  updateLocalState({\n    open\n  });\n  updateParentState(searchTerm);\n};\n\n// handle on keydown\nAutoCompleteInput.handleCloseAutoComplete = (\n  updateLocalState,\n  state,\n  updateParentState,\n  updateCurrentPage,\n) => (event,) => {\n  // When user press ESC key\n  // Close the suggestion box and reset all suggestions\n  if (event.which === 27) {\n    updateLocalState({\n      open: false,\n      suggestedItems: []\n    });\n  } else if (event.keyCode === 13) {\n    // When Enter\n    // if there is a suggested option pass it to the state if not check if -1 and just send the current search term\n    // reset the suggestions and close the box and algo depending of the position\n    // of the current option it will return the suggested option or tbe search Term\n    // only if the current option is bigger or equal to 0 it will return the suggestion\n    const processSearch =\n      state.currentOption === -1\n        ? state.searchTerm\n        : state.suggestedItems[state.currentOption];\n    updateLocalState({\n      open: false,\n      searchTerm: processSearch,\n      suggestedItems: [],\n      currentOption: -1\n    });\n    // Get pagination to page 1\n    updateCurrentPage(0);\n    updateParentState(processSearch);\n  } else if (event.keyCode === 40) {\n    // When arrow up\n    // select and option controlled by keyboard\n    // everytime the user clicks arrow up button it will decrease\n    // the suggestion options\n    // suggestion options cant be less than -1 so in this case\n    // when click up always returns -1\n    updateLocalState(prevState => {\n      const arrayItem = prevState.suggestedItems.length - 1;\n      const maxOption =\n        prevState.currentOption < arrayItem\n          ? prevState.currentOption + 1\n          : arrayItem;\n      return {\n        currentOption: maxOption\n      };\n    });\n  } else if (event.keyCode === 38) {\n        // When arrow down\n    // select and option controlled by keyboard\n    // everytime the user clicks arrow down button it will increase\n    // the suggestion options\n\n    updateLocalState(prevState => {\n      // If not selected option return -1\n      const minOption =\n        prevState.currentOption < 1 ? -1 : prevState.currentOption - 1;\n      return {\n        currentOption: minOption\n      };\n    });\n  } else if (event.keyCode === 9) {\n    updateLocalState({\n      currentOption: 0,\n      suggestedItems: [],\n      open: false\n    });\n  }\n};\n\nexport default AutoCompleteInput;\n"]},"metadata":{},"sourceType":"module"}